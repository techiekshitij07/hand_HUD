<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Hand HUD</title>
	<link rel="preconnect" href="https://cdn.jsdelivr.net" />
	<link rel="stylesheet" href="styles.css" />
</head>
<body>
	<div id="app">
		<video id="webcam" playsinline autoplay muted></video>
		<canvas id="overlay"></canvas>
		<div id="cta">
			<button id="startBtn">Enable Camera</button>
			<select id="modeSelect" title="Performance">
				<option value="speed" selected>Speed</option>
				<option value="quality">Quality</option>
			</select>
		</div>
	</div>

	<script type="module">
		import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs";

		const video = document.getElementById("webcam");
		const canvas = document.getElementById("overlay");
		const ctx = canvas.getContext("2d");
		const startBtn = document.getElementById("startBtn");
		
		// Cool effects system
		const effects = {
			particles: [],
			trails: [],
			energy: [],
			sparks: []
		};
		const hudState = { t: 0, lastVideoTime: -1, seed: Math.random() };
		// Performance knobs (runtime adjustable)
		let MAX_HANDS = 1; // Track one hand for speed
		let MODEL_VARIANT = "full"; // "lite" (fast) or "full" (accurate) - lite model 404s
		let VIDEO_WIDTH = 640;
		let VIDEO_HEIGHT = 480;
		let FRAME_RATE = 30;

		let handLandmarker = null;

		async function createDetector() {
			const filesetResolver = await FilesetResolver.forVisionTasks(
				"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
			);
			const modelUrl = MODEL_VARIANT === "lite"
				? "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker_lite/float16/1/hand_landmarker_lite.task"
				: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task";
			handLandmarker = await HandLandmarker.createFromOptions(filesetResolver, {
				baseOptions: {
					modelAssetPath: modelUrl,
					delegate: "GPU",
				},
				numHands: MAX_HANDS,
				runningMode: "VIDEO",
			});
		}

		function resize() {
			const { videoWidth, videoHeight } = video;
			if (!videoWidth || !videoHeight) return;
			const dpr = Math.min(window.devicePixelRatio || 1, 2);
			canvas.width = Math.floor(videoWidth * dpr);
			canvas.height = Math.floor(videoHeight * dpr);
			canvas.style.width = videoWidth + "px";
			canvas.style.height = videoHeight + "px";
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			ctx.scale(dpr, dpr);
		}

		async function enableCamera() {
			await createDetector();
			const stream = await navigator.mediaDevices.getUserMedia({
				video: {
					facingMode: "user",
					width: { ideal: VIDEO_WIDTH },
					height: { ideal: VIDEO_HEIGHT },
					frameRate: { ideal: FRAME_RATE, max: FRAME_RATE }
				},
				audio: false
			});
			video.srcObject = stream;
			await video.play();
			resize();
			requestAnimationFrame(loop);
		}

		startBtn.addEventListener("click", () => {
			startBtn.disabled = true;
			enableCamera().catch((err) => {
				console.error(err);
				startBtn.disabled = false;
			});
		});

		// UI: switch between Speed and Quality presets
		const modeSelect = document.getElementById("modeSelect");
		async function stopStream() {
			const s = video.srcObject;
			if (s && s.getTracks) s.getTracks().forEach(tr => tr.stop());
			video.srcObject = null;
		}
		async function restartPipeline() {
			await stopStream();
			try { handLandmarker && handLandmarker.close && handLandmarker.close(); } catch(e) {}
			handLandmarker = null;
			await enableCamera();
		}
		modeSelect.addEventListener("change", async () => {
			const preset = modeSelect.value;
			if (preset === "speed") {
				MODEL_VARIANT = "full"; // lite model 404s, using full for now
				MAX_HANDS = 1;
				VIDEO_WIDTH = 640; VIDEO_HEIGHT = 480; FRAME_RATE = 30;
			} else {
				MODEL_VARIANT = "full";
				MAX_HANDS = 2;
				VIDEO_WIDTH = 960; VIDEO_HEIGHT = 720; FRAME_RATE = 30;
			}
			if (startBtn.disabled) await restartPipeline();
		});

		window.addEventListener("resize", resize);

		const HAND_CONNECTIONS = [
			// Thumb
			[0, 1], [1, 2], [2, 3], [3, 4],
			// Index
			[0, 5], [5, 6], [6, 7], [7, 8],
			// Middle
			[0, 9], [9, 10], [10, 11], [11, 12],
			// Ring
			[0, 13], [13, 14], [14, 15], [15, 16],
			// Pinky
			[0, 17], [17, 18], [18, 19], [19, 20],
			// Cross links (knuckles)
			[5, 9], [9, 13], [13, 17], [17, 5]
		];

		function toPx([x, y]) {
			// Video and canvas are mirrored with CSS. Use raw coordinates.
			return [x * video.videoWidth, y * video.videoHeight];
		}

		function drawHUDBase() {
			// Bottom-left grid and cube
			const gridX = 24, gridY = video.videoHeight - 120;
			ctx.save();
			ctx.translate(gridX, gridY);
			ctx.strokeStyle = "#6178ff";
			ctx.lineWidth = 1.5;
			ctx.shadowColor = "rgba(97,120,255,0.6)";
			ctx.shadowBlur = 6;
			for (let i = 0; i <= 6; i++) {
				ctx.beginPath();
				ctx.moveTo(0, i * 12);
				ctx.lineTo(72, i * 12);
				ctx.stroke();
			}
			for (let i = 0; i <= 6; i++) {
				ctx.beginPath();
				ctx.moveTo(i * 12, 0);
				ctx.lineTo(i * 12 + 24, -24);
				ctx.stroke();
			}
			// Cube
			ctx.strokeStyle = "#ff6a3d";
			ctx.beginPath();
			ctx.rect(96, -72, 60, 60);
			ctx.stroke();
			ctx.beginPath();
			ctx.rect(114, -90, 60, 60);
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(96, -72); ctx.lineTo(114, -90);
			ctx.moveTo(156, -72); ctx.lineTo(174, -90);
			ctx.moveTo(156, -12); ctx.lineTo(174, -30);
			ctx.moveTo(96, -12); ctx.lineTo(114, -30);
			ctx.stroke();
			ctx.restore();
		}

		function drawRing(x, y, r, rotation, color) {
			ctx.save();
			ctx.translate(x, y);
			ctx.rotate(rotation);
			ctx.strokeStyle = color;
			ctx.lineWidth = 2;
			ctx.lineCap = "round";
			ctx.shadowColor = "rgba(255,255,255,0.7)";
			ctx.shadowBlur = 4;
			for (let i = 0; i < 3; i++) {
				ctx.beginPath();
				ctx.arc(0, 0, r + i * 4, 0.8 * Math.PI, 1.6 * Math.PI);
				ctx.stroke();
			}
			// Tick marks
			for (let i = 0; i < 8; i++) {
				const a = (i / 8) * Math.PI * 2;
				ctx.beginPath();
				ctx.moveTo(Math.cos(a) * (r + 6), Math.sin(a) * (r + 6));
				ctx.lineTo(Math.cos(a) * (r + 12), Math.sin(a) * (r + 12));
				ctx.stroke();
			}
			ctx.restore();
		}

		function drawFingertipGizmo(x, y, t) {
			drawRing(x, y, 10, t * 0.04, "#ffffff");
			ctx.fillStyle = "#fff";
			ctx.beginPath();
			ctx.arc(x, y, 2.5, 0, Math.PI * 2);
			ctx.fill();
		}

		function centroid(points) {
			let sx = 0, sy = 0;
			for (const p of points) { sx += p[0]; sy += p[1]; }
			return [sx / points.length, sy / points.length];
		}

		function drawPalmHUD(landmarks, t) {
			const mcpIndices = [0, 5, 9, 13, 17];
			const pts = mcpIndices.map(i => toPx([landmarks[i].x, landmarks[i].y]));
			const [cx, cy] = centroid(pts);
			drawRing(cx, cy, 22, t * 0.03, "#ffffff");
			ctx.strokeStyle = "#ffffff";
			ctx.lineWidth = 1.5;
			ctx.lineCap = "round";
			ctx.shadowColor = "rgba(255,255,255,0.6)";
			ctx.shadowBlur = 4;
			ctx.beginPath();
			for (let i = 0; i < pts.length; i++) {
				const [x, y] = pts[i];
				ctx.moveTo(cx, cy);
				ctx.lineTo(x, y);
			}
			ctx.stroke();

			// Readout text
			ctx.font = "14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
			ctx.fillStyle = "#ffffff";
			ctx.fillText(`rotation ${Math.floor((t % 360))}`, cx - 40, cy + 48);
		}

		function drawSkeleton(landmarks) {
			ctx.strokeStyle = "#ffffff";
			ctx.lineWidth = 2;
			ctx.lineCap = "round";
			ctx.shadowColor = "rgba(255,255,255,0.6)";
			ctx.shadowBlur = 6;
			ctx.beginPath();
			for (const [a, b] of HAND_CONNECTIONS) {
				const pa = toPx([landmarks[a].x, landmarks[a].y]);
				const pb = toPx([landmarks[b].x, landmarks[b].y]);
				ctx.moveTo(pa[0], pa[1]);
				ctx.lineTo(pb[0], pb[1]);
				
				// Add trail effect
				effects.trails.push({
					x: pa[0], y: pa[1],
					life: 30,
					alpha: 0.8
				});
			}
			ctx.stroke();
		}

		function drawJointDots(landmarks, t) {
			ctx.fillStyle = "#ffffff";
			ctx.shadowColor = "rgba(255,255,255,0.85)";
			ctx.shadowBlur = 8;
			for (let i = 0; i < landmarks.length; i++) {
				const [x, y] = toPx([landmarks[i].x, landmarks[i].y]);
				const r = (i % 4 === 0 || i === 0) ? 2.8 : 2.0;
				ctx.beginPath();
				ctx.arc(x, y, r, 0, Math.PI * 2);
				ctx.fill();
				if ([4,8,12,16,20,0,5,9,13,17].includes(i)) {
					drawRing(x, y, 8, t * 0.05 + i * 0.2, "#ffffff");
					// Add energy particles around fingertips
					if (Math.random() < 0.3) {
						effects.energy.push({
							x: x + (Math.random() - 0.5) * 20,
							y: y + (Math.random() - 0.5) * 2,
							vx: (Math.random() - 0.5) * 2,
							vy: (Math.random() - 0.5) * 2,
							life: 60,
							color: `hsl(${200 + Math.random() * 60}, 80%, 70%)`
						});
					}
				}
			}
		}

		const prevByHandIndex = new Map();
		function smoothLandmarks(raw, handIndex) {
			const alpha = 0.35;
			const prev = prevByHandIndex.get(handIndex) || raw;
			const smoothed = raw.map((p, i) => ({
				x: prev[i] ? prev[i].x * (1 - alpha) + p.x * alpha : p.x,
				y: prev[i] ? prev[i].y * (1 - alpha) + p.y * alpha : p.y,
				z: p.z
			}));
			prevByHandIndex.set(handIndex, smoothed);
			return smoothed;
		}

		function loop(t) {
			if (!handLandmarker) return;
			hudState.t = t * 0.06; // slow time
			if (video.currentTime === hudState.lastVideoTime) {
				requestAnimationFrame(loop);
				return;
			}
			hudState.lastVideoTime = video.currentTime;
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			drawHUDBase();

			// Update and draw effects
			updateEffects();
			drawEffects();

			const result = handLandmarker.detectForVideo(video, performance.now());
			const hands = result.landmarks || [];
			for (let hi = 0; hi < hands.length; hi++) {
				const hand = smoothLandmarks(hands[hi], hi);
				drawSkeleton(hand);
				drawPalmHUD(hand, hudState.t);
				drawJointDots(hand, hudState.t);
				// Fingertips indices: 4, 8, 12, 16, 20
				[4, 8, 12, 16, 20].forEach(i => {
					const [x, y] = toPx([hand[i].x, hand[i].y]);
					drawFingertipGizmo(x, y, hudState.t);
				});
			}

			requestAnimationFrame(loop);
		}
		
		// Effects system
		function updateEffects() {
			// Update energy particles
			effects.energy = effects.energy.filter(p => {
				p.x += p.vx;
				p.y += p.vy;
				p.life--;
				return p.life > 0;
			});
			
			// Update trails
			effects.trails = effects.trails.filter(t => {
				t.life--;
				t.alpha *= 0.95;
				return t.life > 0 && t.alpha > 0.1;
			});
			
			// Add ambient particles
			if (Math.random() < 0.1) {
				effects.particles.push({
					x: Math.random() * canvas.width,
					y: Math.random() * canvas.height,
					vx: (Math.random() - 0.5) * 0.5,
					vy: (Math.random() - 0.5) * 0.5,
					life: 120,
					size: Math.random() * 2 + 1
				});
			}
			
			// Update ambient particles
			effects.particles = effects.particles.filter(p => {
				p.x += p.vx;
				p.y += p.vy;
				p.life--;
				return p.life > 0 && p.x > 0 && p.x < canvas.width && p.y > 0 && p.y < canvas.height;
			});
		}
		
		function drawEffects() {
			// Draw energy particles
			effects.energy.forEach(p => {
				ctx.save();
				ctx.globalAlpha = p.life / 60;
				ctx.fillStyle = p.color;
				ctx.shadowColor = p.color;
				ctx.shadowBlur = 10;
				ctx.beginPath();
				ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
				ctx.fill();
				ctx.restore();
			});
			
			// Draw trails
			effects.trails.forEach(t => {
				ctx.save();
				ctx.globalAlpha = t.alpha;
				ctx.fillStyle = "#00ffff";
				ctx.shadowColor = "#00ffff";
				ctx.shadowBlur = 8;
				ctx.beginPath();
				ctx.arc(t.x, t.y, 2, 0, Math.PI * 2);
				ctx.fill();
				ctx.restore();
			});
			
			// Draw ambient particles
			effects.particles.forEach(p => {
				ctx.save();
				ctx.globalAlpha = p.life / 120;
				ctx.fillStyle = "#ffffff";
				ctx.shadowColor = "#ffffff";
				ctx.shadowBlur = 4;
				ctx.beginPath();
				ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
				ctx.fill();
				ctx.restore();
			});
		}
	</script>
</body>
</html>


